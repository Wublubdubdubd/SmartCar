C251 COMPILER V5.60.0,  isr                                                                05/05/25  18:01:34  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE isr
OBJECT MODULE PLACED IN .\out_file\isr.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE ..\user\isr.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) OPTIMIZE(2,SIZE) B
                    -ROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_driver
                    -;..\user;..\code) DEBUG PRINT(.\out_file\isr.lst) TABS(2) OBJECT(.\out_file\isr.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2          * AI8051U Opensourec Library 即（AI8051U 开源库）是一个基于官方 SDK 接口的第三方开源库
    3          * Copyright (c) 2022 SEEKFREE 逐飞科技
    4          *
    5          * 本文件是STC 开源库的一部分
    6          *
    7          * AI8051U 开源库 是免费软件
    8          * 您可以根据自由软件基金会发布的 GPL（GNU General Public License，即 GNU通用公共许可证）的条款
    9          * 即 GPL 的第3版（即 GPL3.0）或（您选择的）任何后来的版本，重新发布和/或修改它
   10          *
   11          * 本开源库的发布是希望它能发挥作用，但并未对其作任何的保证
   12          * 甚至没有隐含的适销性或适合特定用途的保证
   13          * 更多细节请参见 GPL
   14          *
   15          * 您应该在收到本开源库的同时收到一份 GPL 的副本
   16          * 如果没有，请参阅<https://www.gnu.org/licenses/>
   17          *
   18          * 额外注明：
   19          * 本开源库使用 GPL3.0 开源许可证协议 以上许可申明为译文版本
   20          * 许可申明英文版在 libraries/doc 文件夹下的 GPL3_permission_statement.txt 文件中
   21          * 许可证副本在 libraries 文件夹下 即该文件夹下的 LICENSE 文件
   22          * 欢迎各位使用并传播本程序 但修改内容时必须保留逐飞科技的版权声明（即本声明）
   23          *
   24          * 文件名称          
   25          * 公司名称          成都逐飞科技有限公司
   26          * 版本信息          查看 libraries/doc 文件夹内 version 文件 版本说明
   27          * 开发环境          MDK FOR C251
   28          * 适用平台          AI8051U
   29          * 店铺链接          https://seekfree.taobao.com/
   30          *
   31          * 修改记录
   32          * 日期              作者           备注
   33          * 2024-08-01        大W            first version
   34          *********************************************************************************************************
             -***********/
   35          #include "isr.h"
   36          
   37          void DMA_UART1_IRQHandler (void) interrupt 4
   38          {
   39   1          static vuint8 dwon_count = 0;
   40   1          if (DMA_UR1R_STA & 0x01)    // 接收完成
   41   1          {
   42   2              DMA_UR1R_STA &= ~0x01;    // 清标志位
   43   2              uart_rx_start_buff(UART_1); // 设置下一次接收，务必保留
   44   2              
   45   2              //程序自动下载
   46   2              if(uart_rx_buff[UART_1][0] == 0x7F)
   47   2              {
   48   3                  if(dwon_count++ > 20)
   49   3                  {
   50   4                      IAP_CONTR = 0x60;
   51   4                  }
   52   3              }
   53   2              else
   54   2              {
   55   3                  dwon_count = 0;
C251 COMPILER V5.60.0,  isr                                                                05/05/25  18:01:34  PAGE 2   

   56   3              }
   57   2              
   58   2              if(uart1_irq_handler != NULL)
   59   2              {
   60   3                  uart1_irq_handler(uart_rx_buff[UART_1][0]);
   61   3              }
   62   2          }
   63   1          
   64   1          if (DMA_UR1R_STA & 0x02)  //数据丢弃
   65   1          {
   66   2              DMA_UR1R_STA &= ~0x02;  //清标志位
   67   2              uart_rx_start_buff(UART_1); // 设置下一次接收，务必保留
   68   2              // 如果进入了这个中断，则代表UART的数据在没有取走之前被覆盖!
   69   2              // 如果进入了这个中断，则代表UART的数据在没有取走之前被覆盖!
   70   2              // 如果进入了这个中断，则代表UART的数据在没有取走之前被覆盖!
   71   2          }
   72   1      }
   73          
   74          
   75          
   76          void DMA_UART2_IRQHandler (void) interrupt 8
   77          {
   78   1      
   79   1          if (DMA_UR2R_STA & 0x01)    // 接收完成
   80   1          {
   81   2              DMA_UR2R_STA &= ~0x01;    // 清标志位
   82   2              uart_rx_start_buff(UART_2); // 设置下一次接收，务必保留
   83   2              
   84   2              if(uart2_irq_handler != NULL)
   85   2              {
   86   3                  uart2_irq_handler(uart_rx_buff[UART_2][0]);
   87   3              }
   88   2          }
   89   1          
   90   1          if (DMA_UR2R_STA & 0x02)    //数据丢弃
   91   1          {
   92   2              DMA_UR2R_STA &= ~0x02;    //清标志位
   93   2              uart_rx_start_buff(UART_2); // 设置下一次接收，务必保留
   94   2              // 如果进入了这个中断，则代表UART的数据在没有取走之前被覆盖!
   95   2              // 如果进入了这个中断，则代表UART的数据在没有取走之前被覆盖!
   96   2              // 如果进入了这个中断，则代表UART的数据在没有取走之前被覆盖!
   97   2              
   98   2          }
   99   1      }
  100          
  101          void DMA_UART3_IRQHandler (void) interrupt 17
  102          {
  103   1      
  104   1          if (DMA_UR3R_STA & 0x01)    // 接收完成
  105   1          {
  106   2              DMA_UR3R_STA &= ~0x01;    // 清标志位
  107   2              uart_rx_start_buff(UART_3); // 设置下一次接收，务必保留
  108   2              
  109   2              if(uart3_irq_handler != NULL)
  110   2              {
  111   3              
  112   3                  uart3_irq_handler(uart_rx_buff[UART_3][0]);
  113   3                  
  114   3              }
  115   2          }
  116   1          
  117   1          if (DMA_UR3R_STA & 0x02)    //数据丢弃
  118   1          {
  119   2              DMA_UR3R_STA &= ~0x02;    //清标志位
  120   2              uart_rx_start_buff(UART_3); // 设置下一次接收，务必保留
  121   2              // 如果进入了这个中断，则代表UART的数据在没有取走之前被覆盖!
C251 COMPILER V5.60.0,  isr                                                                05/05/25  18:01:34  PAGE 3   

  122   2              // 如果进入了这个中断，则代表UART的数据在没有取走之前被覆盖!
  123   2              // 如果进入了这个中断，则代表UART的数据在没有取走之前被覆盖!
  124   2              
  125   2          }
  126   1      }
  127          
  128          void DMA_UART4_IRQHandler (void) interrupt 18
  129          {
  130   1      
  131   1          if (DMA_UR4R_STA & 0x01)    // 接收完成
  132   1          {
  133   2              DMA_UR4R_STA &= ~0x01;    // 清标志位
  134   2              uart_rx_start_buff(UART_4); // 设置下一次接收，务必保留
  135   2              
  136   2              if(uart4_irq_handler != NULL)
  137   2              {
  138   3                  uart4_irq_handler(uart_rx_buff[UART_4][0]);
  139   3                  
  140   3              }
  141   2          }
  142   1          
  143   1          if (DMA_UR4R_STA & 0x02)  //数据丢弃
  144   1          {
  145   2              DMA_UR4R_STA &= ~0x02;  //清标志位
  146   2              uart_rx_start_buff(UART_4); // 设置下一次接收，务必保留
  147   2              // 如果进入了这个中断，则代表UART的数据在没有取走之前被覆盖!
  148   2              // 如果进入了这个中断，则代表UART的数据在没有取走之前被覆盖!
  149   2              // 如果进入了这个中断，则代表UART的数据在没有取走之前被覆盖!
  150   2              
  151   2          }
  152   1      }
  153          
  154          
  155          void TM0_IRQHandler() interrupt 1
  156          {
  157   1          TIM0_CLEAR_FLAG;
  158   1          
  159   1          if(tim0_irq_handler != NULL)
  160   1          {
  161   2              tim0_irq_handler();
  162   2          }
  163   1      }
  164          void TM1_IRQHandler() interrupt 3
  165          {
  166   1          TIM1_CLEAR_FLAG;
  167   1          
  168   1          if(tim1_irq_handler != NULL)
  169   1          {
  170   2              tim1_irq_handler();
  171   2          }
  172   1      }
  173          void TM2_IRQHandler() interrupt 12
  174          {
  175   1          TIM2_CLEAR_FLAG;
  176   1          
  177   1          if(tim2_irq_handler != NULL)
  178   1          {
  179   2              tim2_irq_handler();
  180   2          }
  181   1      }
  182          void TM3_IRQHandler() interrupt 19
  183          {
  184   1          TIM3_CLEAR_FLAG;
  185   1          
  186   1          if(tim3_irq_handler != NULL)
  187   1          {
C251 COMPILER V5.60.0,  isr                                                                05/05/25  18:01:34  PAGE 4   

  188   2              tim3_irq_handler();
  189   2          }
  190   1      }
  191          
  192          void TM4_IRQHandler() interrupt 20
  193          {
  194   1          TIM4_CLEAR_FLAG;
  195   1          
  196   1          if(tim4_irq_handler != NULL)
  197   1          {
  198   2              tim4_irq_handler();
  199   2          }
  200   1      }
  201          
  202          void TM11_IRQHandler() interrupt 24
  203          {
  204   1          TIM11_CLEAR_FLAG;
  205   1          
  206   1          if(tim11_irq_handler != NULL)
  207   1          {
  208   2              tim11_irq_handler();
  209   2          }
  210   1      }
  211          
  212          /**
  213            * @brief TIM0中断处理函数，提取imu数据
  214            * @param 无
  215            * @return 无
  216            */
  217          void pit_hanlder_imu(void)
  218          { 
  219   1          
  220   1          //获取传感器数据
  221   1          imu660ra_get_acc();  // 加速度
  222   1          imu660ra_get_gyro(); // 角速度
  223   1        
  224   1          //acc滤波
  225   1          FOCF(&imu660ra_acc_x,&imu_acc_x_pre,0.05);
  226   1          FOCF(&imu660ra_acc_y,&imu_acc_y_pre,0.1);
  227   1          FOCF(&imu660ra_acc_z,&imu_acc_z_pre,0.1);
  228   1        
  229   1          //gyro滤波
  230   1          FOCF(&imu660ra_gyro_x,&imu_gyro_x_pre,0.1);
  231   1          FOCF(&imu660ra_gyro_y,&imu_gyro_y_pre,0.1);
  232   1          FOCF(&imu660ra_gyro_z,&imu_gyro_z_pre,0.1);
  233   1        
  234   1          //转换为实际物理值，纠正零偏
  235   1          imu_acc[0]=imu660ra_acc_transition(imu660ra_acc_x);
  236   1          imu_acc[1]=imu660ra_acc_transition(imu660ra_acc_y)+0.017;
  237   1          imu_acc[2]=imu660ra_acc_transition(imu660ra_acc_z);
  238   1        
  239   1          x_v += (imu_acc[0] * 0.005);
  240   1       
  241   1          imu_gyro[0]=imu660ra_gyro_transition(imu660ra_gyro_x);
  242   1          imu_gyro[1]=imu660ra_gyro_transition(imu660ra_gyro_y);
  243   1          imu_gyro[2]=imu660ra_gyro_transition(imu660ra_gyro_z);
  244   1        
  245   1          //数据融合获取欧拉角
  246   1          GetEuler(imu_gyro,0.005);
  247   1          
  248   1      }
  249          /**
  250            * @brief TIM1中断处理函数，提取gps数据
  251            * @param 无
  252            * @return 无
  253            */
C251 COMPILER V5.60.0,  isr                                                                05/05/25  18:01:34  PAGE 5   

  254          void pit_hanlder_gps(void)
  255          {
  256   1          //获取gps数据
  257   1          if(gps_tau1201_flag)
  258   1          {
  259   2            gps_tau1201_flag = 0;
  260   2            gps_date_ready = (!gps_data_parse()) ? 1 : 0;
  261   2          }
  262   1          else gps_date_ready = 0;
  263   1      }
  264          /**
  265            * @brief TIM2中断处理函数，更新角度环
  266            * @param 无
  267            * @return 无
  268            */
  269          bit pid_enable = 0; // pid 使能
  270          void pit_hanlder_angle(void)
  271          {
  272   1          uint32 angle_duty;
  273   1          float angle_u = 0 ;//角度环控制量
  274   1          float velocity_u = 0;//速度环控制量
  275   1          if(pid_enable)
  276   1          {
  277   2            // 角度环
  278   2            angle_u = Angle_Pid_fun(0.01);
  279   2            // 速度环
  280   2            velocity_u = Velocity_Pid_fun(0.01);
  281   2          }
  282   1          //左 抬升电机
  283   1          angle_duty = constrain_uint32(duty_up_left);
  284   1          pwm_set_duty(PWM_1,angle_duty);
  285   1          //右 抬升电机
  286   1          angle_duty = constrain_uint32(duty_up_right);
  287   1          pwm_set_duty(PWM_2,angle_duty);
  288   1          //左 推进电机
  289   1          angle_duty = constrain_uint32(duty_forward_left - angle_u + velocity_u);
  290   1          pwm_set_duty(PWM_3,angle_duty);
  291   1          //右 推进电机
  292   1          angle_duty = constrain_uint32(duty_forward_right + angle_u + velocity_u);
  293   1          pwm_set_duty(PWM_4,angle_duty);
  294   1          
  295   1      }
  296          void my_pit_init()
  297          {
  298   1          //设置中断回调函数 5ms采样一次IMU数据
  299   1          tim0_irq_handler = pit_hanlder_imu; 
  300   1          pit_ms_init(PIT_IMU, 5);
  301   1          //设置中断回调函数 1s采样一次GPS数据
  302   1          tim1_irq_handler = pit_hanlder_GPS; 
  303   1          pit_ms_init(PIT_GPS, 1000);
  304   1          //10ms更新一次角度环
  305   1          tim3_irq_handler = pit_hanlder_angle;
  306   1          pit_ms_init(PIT_ANGLE, 10);
  307   1      }
  308          
  309          
  310          //#define     INT0_VECTOR             0       //0003H
  311          //#define     TMR0_VECTOR             1       //000BH
  312          //#define     INT1_VECTOR             2       //0013H
  313          //#define     TMR1_VECTOR             3       //001BH
  314          //#define     UART1_VECTOR            4       //0023H
  315          //#define     ADC_VECTOR              5       //002BH
  316          //#define     LVD_VECTOR              6       //0033H
  317          //#define     PCA_VECTOR              7       //003BH
  318          //#define     UART2_VECTOR            8       //0043H
  319          //#define     SPI_VECTOR              9       //004BH
C251 COMPILER V5.60.0,  isr                                                                05/05/25  18:01:34  PAGE 6   

  320          //#define     INT2_VECTOR             10      //0053H
  321          //#define     INT3_VECTOR             11      //005BH
  322          //#define     TMR2_VECTOR             12      //0063H
  323          //#define     USER_VECTOR             13      //006BH
  324          //#define     INT4_VECTOR             16      //0083H
  325          //#define     UART3_VECTOR            17      //008BH
  326          //#define     UART4_VECTOR            18      //0093H
  327          //#define     TMR3_VECTOR             19      //009BH
  328          //#define     TMR4_VECTOR             20      //00A3H
  329          //#define     CMP_VECTOR              21      //00ABH
  330          //#define     I2C_VECTOR              24      //00C3H
  331          //#define     USB_VECTOR              25      //00CBH
  332          //#define     PWMA_VECTOR             26      //00D3H
  333          //#define     PWMB_VECTOR             27      //00DBH
  334          
  335          //#define     RTC_VECTOR              36      //0123H
  336          //#define     P0INT_VECTOR            37      //012BH
  337          //#define     P1INT_VECTOR            38      //0133H
  338          //#define     P2INT_VECTOR            39      //013BH
  339          //#define     P3INT_VECTOR            40      //0143H
  340          //#define     P4INT_VECTOR            41      //014BH
  341          //#define     P5INT_VECTOR            42      //0153H
  342          //#define     P6INT_VECTOR            43      //015BH
  343          //#define     P7INT_VECTOR            44      //0163H
  344          //#define     DMA_M2M_VECTOR          47      //017BH
  345          //#define     DMA_ADC_VECTOR          48      //0183H
  346          //#define     DMA_SPI_VECTOR          49      //018BH
  347          //#define     DMA_UR1T_VECTOR         50      //0193H
  348          //#define     DMA_UR1R_VECTOR         51      //019BH
  349          //#define     DMA_UR2T_VECTOR         52      //01A3H
  350          //#define     DMA_UR2R_VECTOR         53      //01ABH
  351          //#define     DMA_UR3T_VECTOR         54      //01B3H
  352          //#define     DMA_UR3R_VECTOR         55      //01BBH
  353          //#define     DMA_UR4T_VECTOR         56      //01C3H
  354          //#define     DMA_UR4R_VECTOR         57      //01CBH
  355          //#define     DMA_LCM_VECTOR          58      //01D3H
  356          //#define     LCM_VECTOR              59      //01DBH
  357          //#define     DMA_I2CT_VECTOR         60      //01E3H
  358          //#define     DMA_I2CR_VECTOR         61      //01EBH
  359          //#define     I2S_VECTOR              62      //01F3H
  360          //#define     DMA_I2ST_VECTOR         63      //01FBH
  361          //#define     DMA_I2SR_VECTOR         64      //0203H
  362          //#define     DMA_QSPI_VECTOR         65      //020BH
  363          //#define     QSPI_VECTOR             66      //0213H
  364          //#define     TMR11_VECTOR            67      //021BH
  365          //#define     DMA_PWMAT_VECTOR        72      //0243H
  366          //#define     DMA_PWMAR_VECTOR        73      //024BH


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1978     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        13     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =         1     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =         6     ------
C251 COMPILER V5.60.0,  isr                                                                05/05/25  18:01:34  PAGE 7   

End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
