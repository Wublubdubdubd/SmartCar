C251 COMPILER V5.60.0,  filter                                                             09/05/25  20:54:14  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE filter
OBJECT MODULE PLACED IN .\out_file\filter.obj
COMPILER INVOKED BY: D:\C251\C251\BIN\C251.EXE ..\user\filter.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) OPTIMIZE(2,SIZE) B
                    -ROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_driver
                    -;..\user;..\code) DEBUG PRINT(.\out_file\filter.lst) TABS(2) OBJECT(.\out_file\filter.obj) 

stmt  level    source

    1          #include "filter.h"
    2          /**
    3            * @brief 一阶互补滤波，用于平滑数据
    4            * @param pData: 待滤波的数据  pPreData：前一时刻数据  alpha：滤波参数
    5            * @return 无
    6            */
    7          void FOCF(int16* pData, int16* pPreData, float alpha)
    8          {
    9   1          *pData *= alpha;
   10   1          *pData += (1-alpha)*(*pPreData);
   11   1      }
   12          /**
   13            * @brief atan2
   14            * @param 
   15            * @return 弧度制
   16            */
   17          double my_atan2(double y, double x) {
   18   1          // 处理x = 0的情况
   19   1          if (x == 0) {
   20   2              if (y > 0) {
   21   3                  return M_PI / 2; // y轴正半轴
   22   3              } else if (y < 0) {
   23   3                  return -M_PI / 2; // y轴负半轴
   24   3              } else {
   25   3                  return 0; // 原点
   26   3              }
   27   2          }
   28   1          else{
   29   2          // 计算基础角度
   30   2          double theta = atan(y / x);
   31   2      
   32   2          // 处理x ≠ 0的情况
   33   2          if (x > 0) {
   34   3              return theta; // 第一象限和第四象限
   35   3         // 处理x < 0的情况
   36   3          } else {
   37   3              if (y > 0) {
   38   4                  return theta + M_PI; // 第二象限或x轴负半轴
   39   4              } else {
   40   4                  return theta - M_PI; // 第三象限
   41   4              }
   42   3           }
   43   2        }
   44   1      }
   45          /**
   46            * @brief 使用四元数法进行IMU数据融合获取欧拉角
   47            * @param acc：加速度计数据 gyro：陀螺仪数据 dt：积分时长
   48            * @return 无
   49            */
   50          void GetEuler(float gyro[], float dt) 
   51          {
   52   1          float norm; // 归一化因子
   53   1      
   54   1          // 陀螺仪数据转换为弧度/秒（因输入gyro[]单位为°/s）
   55   1          float gx = gyro[0] * 0.0174533f; // °/s -> rad/s
   56   1          float gy = gyro[1] * 0.0174533f;
   57   1          float gz = gyro[2] * 0.0174533f;
C251 COMPILER V5.60.0,  filter                                                             09/05/25  20:54:14  PAGE 2   

   58   1      
   59   1          // 四元数更新（仅陀螺仪积分）
   60   1          q0 += (-q1 * gx - q2 * gy - q3 * gz) * 0.5f * dt;
   61   1          q1 += ( q0 * gx + q2 * gz - q3 * gy) * 0.5f * dt;
   62   1          q2 += ( q0 * gy - q1 * gz + q3 * gx) * 0.5f * dt;
   63   1          q3 += ( q0 * gz + q1 * gy - q2 * gx) * 0.5f * dt;
   64   1      
   65   1          // 四元数归一化（防止数值发散）
   66   1          norm = sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);
   67   1          if (norm == 0.0f) return;
   68   1          q0 /= norm;
   69   1          q1 /= norm;
   70   1          q2 /= norm;
   71   1          q3 /= norm;
   72   1      
   73   1          // 四元数转欧拉角（弧度转角度）
   74   1          roll  = my_atan2(2.0f * (q0 * q1 + q2 * q3), 1.0f - 2.0f * (q1 * q1 + q2 * q2)) * 57.29578f;
   75   1          pitch = asin(2.0f * (q0 * q2 - q3 * q1)) * 57.29578f;
   76   1          yaw   = my_atan2(2.0f * (q0 * q3 + q1 * q2), 1.0f - 2.0f * (q2 * q2 + q3 * q3)) * 57.29578f;
   77   1      }
   78          void EulerToQuaternion()
   79          {
   80   1          // 转换为弧度
   81   1          float roll_rad = roll* 0.0174533f;  // π/180 ≈ 0.0174533
   82   1          float pitch_rad = pitch * 0.0174533f;
   83   1          float yaw_rad = yaw * 0.0174533f;
   84   1        
   85   1          double cr = cos(roll_rad * 0.5f);  // cos(φ/2)
   86   1          double sr = sin(roll_rad * 0.5f);  // sin(φ/2)
   87   1          double cp = cos(pitch_rad * 0.5f); // cos(θ/2)
   88   1          double sp = sin(pitch_rad * 0.5f); // sin(θ/2)
   89   1          double cy = cos(yaw_rad * 0.5f);   // cos(ψ/2)
   90   1          double sy = sin(yaw_rad * 0.5f);   // sin(ψ/2)
   91   1      
   92   1          q0 = cy * cp * cr + sy * sp * sr; // q0 = w
   93   1          q1 = cy * cp * sr - sy * sp * cr; // q1 = x
   94   1          q2 = sy * cp * sr + cy * sp * cr; // q2 = y
   95   1          q3 = sy * cp * cr - cy * sp * sr; // q3 = z
   96   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2838     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       120     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =    ------     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
