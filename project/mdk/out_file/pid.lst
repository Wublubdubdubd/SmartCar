C251 COMPILER V5.60.0,  pid                                                                09/05/25  22:47:17  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE pid
OBJECT MODULE PLACED IN .\out_file\pid.obj
COMPILER INVOKED BY: D:\C251\C251\BIN\C251.EXE ..\user\pid.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) OPTIMIZE(2,SIZE) BROW
                    -SE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_driver;..
                    -\user;..\code) DEBUG PRINT(.\out_file\pid.lst) TABS(2) OBJECT(.\out_file\pid.obj) 

stmt  level    source

    1          #include "pid.h"
    2          
    3          // 角度PID初始化参数
    4          float angle_KP = 1.0, angle_KI = 1.0,angle_KD = 1.0, angle_IMAX = 60, angle_OUTMAX = 120;
    5          
    6          pid_param_t angle_pid; //角度PID
    7          float angle_target = 0;//角度输入
    8          float angle_error = 0; //角度误差
    9          float angle_u = 0 ;//角度环控制量
   10          
   11          // 速度PID初始化参数
   12          float velocity_KP = 600.0, velocity_KI = 60,velocity_KD = 0, velocity_IMAX = 140, velocity_OUTMAX = 200;
   13          
   14          pid_param_t velocity_pid; //速度PID
   15          float velocity_target = 0.05;//速度输入
   16          float velocity_error = 0; //速度误差
   17          float velocity_u = 0;//速度环控制量
   18          
   19          
   20          float Angle_Pid_fun(float dt)
   21          {  
   22   1          if(curState == State_Subject_1)
   23   1          {
   24   2            angle_target = get_two_points_azimuth(gps_tau1201.latitude,gps_tau1201.longitude,target_point[0],targe
             -t_point[1]);
   25   2            if( 180 <= angle_target < 360)
   26   2                angle_target -= 360;
   27   2          }
   28   1          angle_error = (-angle_target) - yaw;
   29   1          
   30   1          //角度环
   31   1          PidLocCtrl(&angle_pid,angle_error, dt);
   32   1        
   33   1          return angle_pid.out;
   34   1      }
   35          
   36          float Velocity_Pid_fun(float dt)
   37          {  
   38   1          velocity_error = velocity_target - velocity;
   39   1          //速度环
   40   1          PidLocCtrl(&velocity_pid,velocity_error, dt);
   41   1        
   42   1          return velocity_pid.out;
   43   1      }
   44          
   45          /*******************************************************************************
   46          * 函 数 名         : My_Pid_Init
   47          * 函数功能         : PID初始化 
   48          * 输    入         : 无
   49          * 输    出         : 无
   50          *******************************************************************************/
   51          void My_Pid_Init(void)
   52          {
   53   1          Pid_Param_Init(&angle_pid,angle_KP, angle_KI,angle_KD, angle_IMAX, angle_OUTMAX);
   54   1          Pid_Param_Init(&velocity_pid,velocity_KP, velocity_KI,velocity_KD, velocity_IMAX, velocity_OUTMAX);
   55   1      }
   56          
C251 COMPILER V5.60.0,  pid                                                                09/05/25  22:47:17  PAGE 2   

   57          
   58          /*******************************************************************************
   59          * 函 数 名         : Pid_Param_Init
   60          * 函数功能         : PID参数初始化 
   61          * 输    入         : imax:积分项最大值
   62          * 输    出         : 无
   63          *******************************************************************************/
   64          void Pid_Param_Init(pid_param_t * pid, float kp, float ki, float kd, float imax, float outmax)
   65          {
   66   1          pid->kp        = kp;
   67   1          pid->ki        = ki;
   68   1          pid->kd        = kd;
   69   1          pid->imax      = imax;
   70   1          pid->out_p     = 0;
   71   1          pid->out_i     = 0;
   72   1          pid->out_d     = 0;
   73   1          pid->out       = 0;
   74   1          pid->outmax    = outmax;
   75   1          pid->integrator= 0;
   76   1          pid->last_error= 0;
   77   1          pid->last_derivative   = 0;
   78   1          pid->last_t    = 0;
   79   1      }
   80          
   81          /*******************************************************************************
   82          * 函 数 名         : PidLocCtrl
   83          * 函数功能     : 位置式PID控制
   84          * 输    入         : pid, error, t
   85          * 输    出         : float
   86          *******************************************************************************/
   87          float PidLocCtrl(pid_param_t * pid, float error, float t)
   88          {
   89   1          /* 累积误差 */
   90   1          pid->integrator += error;
   91   1      
   92   1          /* 误差限幅 */
   93   1          pid->out_i = constrain_float(pid->integrator, -pid->imax, pid->imax);
   94   1      
   95   1      
   96   1          pid->out_p = pid->kp * error;
   97   1          pid->out_i = pid->ki * t * pid->integrator;
   98   1          pid->out_d = pid->kd/t * (error - pid->last_error);
   99   1      
  100   1          pid->last_error = error;
  101   1      
  102   1          pid->out = pid->out_p + pid->out_i + pid->out_d;
  103   1      
  104   1          pid->out = constrain_float(pid->out, -pid->outmax, pid->outmax);
  105   1      
  106   1          return pid->out;
  107   1      }
  108          
  109          
  110          /*******************************************************************************
  111          * 函 数 名         : PidIncCtrl
  112          * 函数功能     : 增量式PID控制
  113          * 输    入         : pid, error, t
  114          * 输    出         : float
  115          *******************************************************************************/
  116          float PidIncCtrl(pid_param_t * pid, float error, float t)
  117          {
  118   1      
  119   1          pid->out_p = pid->kp * (error - pid->last_error);
  120   1          pid->out_i = pid->ki * error * t ;
  121   1          pid->out_d = pid->kd/t * ((error - pid->last_error) - pid->last_derivative);
  122   1      
C251 COMPILER V5.60.0,  pid                                                                09/05/25  22:47:17  PAGE 3   

  123   1          pid->last_derivative = error - pid->last_error;
  124   1          pid->last_error = error;
  125   1      
  126   1          pid->out += pid->out_p + pid->out_i + pid->out_d;
  127   1      
  128   1          pid->out = constrain_float(pid->out, -pid->outmax, pid->outmax);
  129   1          return pid->out;
  130   1      }
  131          
  132          /*******************************************************************************
  133          * 函 数 名         : constrain_float
  134          * 函数功能         : 浮点型数限幅
  135          * 输    入         : amt,low,high
  136          * 输    出         : float
  137          *******************************************************************************/
  138          float constrain_float(float amt, float low, float high)
  139          {
  140   1          return ((amt)<(low)?(low):((amt)>(high)?(high):(amt)));
  141   1      }
  142          
  143          /*******************************************************************************
  144          * 函 数 名         : constrain_short
  145          * 函数功能         : 短整型数限幅
  146          * 输    入         : amt,low,high
  147          * 输    出         : short
  148          *******************************************************************************/
  149          short constrain_short(short amt, short low, short high)
  150          {
  151   1          return ((amt)<(low)?(low):((amt)>(high)?(high):(amt)));
  152   1      }
  153          
  154          /*******************************************************************************
  155          * 函 数 名         : constrain_uint32
  156          * 函数功能         : 限幅
  157          * 输    入         : amt,low,high
  158          * 输    出         : uint32
  159          *******************************************************************************/
  160          unsigned long constrain_uint32(float amt)
  161          {
  162   1          return ((amt)<(500)?(500):((amt)>(max_duty)?(max_duty):(amt)));
  163   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2313     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       246     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       144     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
