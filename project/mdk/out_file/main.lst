C251 COMPILER V5.60.0,  main                                                               10/05/25  10:27:14  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\out_file\main.obj
COMPILER INVOKED BY: D:\C251\C251\BIN\C251.EXE ..\user\main.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) OPTIMIZE(2,SIZE) BRO
                    -WSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_driver;.
                    -.\user;..\code) DEBUG PRINT(.\out_file\main.lst) TABS(2) OBJECT(.\out_file\main.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2          * AI8051U Opensourec Library 即（AI8051U 开源库）是一个基于官方 SDK 接口的第三方开源库
    3          * Copyright (c) 2022 SEEKFREE 逐飞科技
    4          *
    5          * 本文件是STC 开源库的一部分
    6          *
    7          * AI8051U 开源库 是免费软件
    8          * 您可以根据自由软件基金会发布的 GPL（GNU General Public License，即 GNU通用公共许可证）的条款
    9          * 即 GPL 的第3版（即 GPL3.0）或（您选择的）任何后来的版本，重新发布和/或修改它
   10          *
   11          * 本开源库的发布是希望它能发挥作用，但并未对其作任何的保证
   12          * 甚至没有隐含的适销性或适合特定用途的保证
   13          * 更多细节请参见 GPL
   14          *
   15          * 您应该在收到本开源库的同时收到一份 GPL 的副本
   16          * 如果没有，请参阅<https://www.gnu.org/licenses/>
   17          *
   18          * 额外注明：
   19          * 本开源库使用 GPL3.0 开源许可证协议 以上许可申明为译文版本
   20          * 许可申明英文版在 libraries/doc 文件夹下的 GPL3_permission_statement.txt 文件中
   21          * 许可证副本在 libraries 文件夹下 即该文件夹下的 LICENSE 文件
   22          * 欢迎各位使用并传播本程序 但修改内容时必须保留逐飞科技的版权声明（即本声明）
   23          *
   24          * 文件名称          
   25          * 公司名称          成都逐飞科技有限公司
   26          * 版本信息          查看 libraries/doc 文件夹内 version 文件 版本说明
   27          * 开发环境          MDK FOR C251
   28          * 适用平台          AI8051U
   29          * 店铺链接          https://seekfree.taobao.com/
   30          *
   31          * 修改记录
   32          * 日期              作者           备注
   33          * 2024-08-01        大W            first version
   34          *********************************************************************************************************
             -***********/
   35          #include "init.h"
   36          
   37          void main()
   38          {
   39   1          char command[command_size];//蓝牙控制命令
   40   1        
   41   1          char str_buffer[50];//向蓝牙发送信息的buffer
   42   1         
   43   1          float temp_float = 0; // 零时变量
   44   1          
   45   1          //科目一开始
   46   1          pObject = Object_one_index; 
   47   1          cur_object_num = Object_one_num;
   48   1          
   49   1          //设备初始化
   50   1          init();
   51   1          
   52   1          while(1)
   53   1          {
   54   2            get_key();
   55   2            
C251 COMPILER V5.60.0,  main                                                               10/05/25  10:27:14  PAGE 2   

   56   2      #if IPS_USE     
   57   2            IPS114_Show_Info(); //显示必要信息
   58   2      #endif
   59   2            blue_tooth_read(command);
   60   2            /*
   61   2            命令集:
   62   2            s: 记录起始点，计算GPS误差，准备初始化yaw角
   63   2            
   64   2            b: 刹车 四个电机占空比值 0%
   65   2            
   66   2            w: 向当前科目的EEPROM区写当前位置的经纬度，写满后不可再写，只有清除后可再次重新写入。何时写满取决与
             -当前科目（未完善）
   67   2                 
   68   2            e：擦除EEPROM第一页，写索引值 0 
   69   2            
   70   2            */
   71   2            if((curState == State_Init) && key2_flag)curState = State_Unlock;
   72   2            if((page_num == 2) && key3_flag && (is_erase == 0))
   73   2            {
   74   3              W25Q_Erase4K_20(0, 1);//iap_erase_page(0);write_index = 0;//第一页 512k
   75   3              sprintf(str_buffer,"Erease!\r\n");ble6a20_send_string(str_buffer);
   76   3              is_erase = 1 ;
   77   3            }
   78   2            else if ((page_num == 2) && key3_flag && (is_erase == 1))
   79   2              WritePoint(pObject[write_index++]);
   80   2            
   81   2            switch(command[0])
   82   2            {
   83   3              case 's':
   84   3              {
   85   4                if(curState == State_Unlock)
   86   4                {
   87   5                  //装载 P1 至 target
   88   5                  LoadPoint();
   89   5                 
   90   5                  // 计算gps的漂移
   91   5                  gps_point_error[0] = gps_tau1201.latitude - target_point[0];
   92   5                  gps_point_error[1] = gps_tau1201.longitude - target_point[1];
   93   5                  
   94   5                  // 输出提示语句
   95   5                  sprintf(str_buffer,"Start!\r\nGPS Error: lat %lf lon %lf\r\n",gps_point_error[0],gps_point_er
             -ror[1]);ble6a20_send_string(str_buffer);
   96   5                  
   97   5                  // 更新状态
   98   5                  curState = State_Yaw_Init;
   99   5                }
  100   4                break;
  101   4              }
  102   3              case 'b':
  103   3              {
  104   4                curState = State_Shut;
  105   4                sprintf(str_buffer,"Break!\r \n");ble6a20_send_string(str_buffer);
  106   4                break;
  107   4              }
  108   3              case 'w':
  109   3              {
  110   4                WritePoint(pObject[write_index++]);//W25Q_PageProgram_32(0, write_buf, 2);
  111   4                sprintf(str_buffer,"Write P%d!\r\n",write_index);ble6a20_send_string(str_buffer);
  112   4                break;
  113   4              }
  114   3              case 'e':
  115   3              {
  116   4                W25Q_Erase4K_20(0, 1);//iap_erase_page(0);write_index = 0;//第一页 512k
  117   4                sprintf(str_buffer,"Erease!\r\n");ble6a20_send_string(str_buffer);
  118   4                break;
  119   4              }
C251 COMPILER V5.60.0,  main                                                               10/05/25  10:27:14  PAGE 3   

  120   3              case 'A':
  121   3              {
  122   4                temp_float = func_str_to_float(&command[2]);
  123   4                switch(command[1])
  124   4                {
  125   5                  case 'P':angle_KP = temp_float;break;
  126   5                  case 'I':angle_KI = temp_float;break;
  127   5                  case 'D':angle_KD = temp_float;break;
  128   5                }
  129   4                break;
  130   4              }
  131   3              case 'V':
  132   3              {
  133   4                temp_float = func_str_to_float(&command[2]);
  134   4                switch(command[1])
  135   4                {
  136   5                  case 'P':velocity_KP = temp_float;break;
  137   5                  case 'I':velocity_KI = temp_float;break;
  138   5                  case 'D':velocity_KD = temp_float;break;
  139   5                }
  140   4                break;          
  141   4              }
  142   3              case 'U':
  143   3              {
  144   4                curState = State_Yaw_Init;
  145   4                sprintf(str_buffer,"Start!\r\n");ble6a20_send_string(str_buffer);
  146   4                break;
  147   4              }
  148   3              default :;
  149   3            }
  150   2            //LoadPoint();
  151   2            //sprintf(str_buffer,"P%d : %.8lf %.8lf\r\n",cur_point_num,target_point[0],target_point[1]);ble6a20_se
             -nd_string(str_buffer);
  152   2            memset(command,0,command_size);
  153   2            refresh_button();
  154   2            
  155   2            switch(curState)
  156   2            {
  157   3              case State_Yaw_Init:
  158   3              {
  159   4                target_distance = get_two_points_distance(target_point[0],target_point[1],gps_tau1201.latitude,
             -gps_tau1201.longitude);
  160   4              
  161   4                //sprintf(str_buffer,"D:%lf \r\n",target_distance);ble6a20_send_string(str_buffer);
  162   4                
  163   4                // 离开两米后
  164   4                if(target_distance > 2)
  165   4                {
  166   5                  //计算yaw角
  167   5                  yaw = get_two_points_azimuth(target_point[0],target_point[1],gps_tau1201.latitude,gps_tau1201
             -.longitude);
  168   5                  //修正至-180~180
  169   5                  if( (180 <= yaw) && (yaw < 360))
  170   5                    yaw -= 360;
  171   5                  //修正到imu坐标系
  172   5                  yaw = - yaw;
  173   5                  //修正四元数
  174   5                  EulerToQuaternion();
  175   5                  //提示信息
  176   5                  sprintf(str_buffer,"Init! D:%lf Y:%lf\r\n",target_distance,yaw);ble6a20_send_string(str_buffe
             -r);
  177   5                  //装载下一目标点
  178   5                  LoadPoint();
  179   5      
  180   5                  sprintf(str_buffer,"Load P%d!\r\n",cur_point_num);ble6a20_send_string(str_buffer);
  181   5                  
C251 COMPILER V5.60.0,  main                                                               10/05/25  10:27:14  PAGE 4   

  182   5                  curState = State_Subject_1;
  183   5                  
  184   5                  target_distance = 999;
  185   5                }
  186   4                break;
  187   4              }
  188   3              case State_Subject_1:
  189   3              {
  190   4                sprintf(str_buffer,"Error:%f!\r\n",angle_error);ble6a20_send_string(str_buffer);
  191   4      
  192   4                target_distance = get_two_points_distance(gps_tau1201.latitude,gps_tau1201.longitude,target_poi
             -nt[0],target_point[1]);
  193   4      
  194   4                if(target_distance < 2)
  195   4                {
  196   5                   //到达目标点
  197   5                   sprintf(str_buffer,"Arrival P%d! D:%lf \r\n",cur_point_num,target_distance);ble6a20_send_str
             -ing(str_buffer);
  198   5      
  199   5                   //装载下一目标点
  200   5                   LoadPoint();
  201   5                   sprintf(str_buffer,"Load P%d!\r\n",cur_point_num);ble6a20_send_string(str_buffer);
  202   5                }
  203   4                break;
  204   4              }
  205   3              case State_Finish:
  206   3              {
  207   4                sprintf(str_buffer,"Finish!\r\n");ble6a20_send_string(str_buffer);
  208   4                while(1){};
  209   4              }
  210   3            }
  211   2      
  212   2            if(cur_point_num == cur_object_num)//先更新为结束状态
  213   2            {
  214   3              curState = State_Finish;
  215   3            }
  216   2            
  217   2            
  218   2          }
  219   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1990     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       118     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       155     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
