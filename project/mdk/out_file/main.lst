C251 COMPILER V5.60.0,  main                                                               09/05/25  22:28:36  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\out_file\main.obj
COMPILER INVOKED BY: D:\C251\C251\BIN\C251.EXE ..\user\main.c LARGE NOALIAS FLOAT64 WARNINGLEVEL(3) OPTIMIZE(2,SIZE) BRO
                    -WSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_driver;.
                    -.\user;..\code) DEBUG PRINT(.\out_file\main.lst) TABS(2) OBJECT(.\out_file\main.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2          * AI8051U Opensourec Library 即（AI8051U 开源库）是一个基于官方 SDK 接口的第三方开源库
    3          * Copyright (c) 2022 SEEKFREE 逐飞科技
    4          *
    5          * 本文件是STC 开源库的一部分
    6          *
    7          * AI8051U 开源库 是免费软件
    8          * 您可以根据自由软件基金会发布的 GPL（GNU General Public License，即 GNU通用公共许可证）的条款
    9          * 即 GPL 的第3版（即 GPL3.0）或（您选择的）任何后来的版本，重新发布和/或修改它
   10          *
   11          * 本开源库的发布是希望它能发挥作用，但并未对其作任何的保证
   12          * 甚至没有隐含的适销性或适合特定用途的保证
   13          * 更多细节请参见 GPL
   14          *
   15          * 您应该在收到本开源库的同时收到一份 GPL 的副本
   16          * 如果没有，请参阅<https://www.gnu.org/licenses/>
   17          *
   18          * 额外注明：
   19          * 本开源库使用 GPL3.0 开源许可证协议 以上许可申明为译文版本
   20          * 许可申明英文版在 libraries/doc 文件夹下的 GPL3_permission_statement.txt 文件中
   21          * 许可证副本在 libraries 文件夹下 即该文件夹下的 LICENSE 文件
   22          * 欢迎各位使用并传播本程序 但修改内容时必须保留逐飞科技的版权声明（即本声明）
   23          *
   24          * 文件名称          
   25          * 公司名称          成都逐飞科技有限公司
   26          * 版本信息          查看 libraries/doc 文件夹内 version 文件 版本说明
   27          * 开发环境          MDK FOR C251
   28          * 适用平台          AI8051U
   29          * 店铺链接          https://seekfree.taobao.com/
   30          *
   31          * 修改记录
   32          * 日期              作者           备注
   33          * 2024-08-01        大W            first version
   34          *********************************************************************************************************
             -***********/
   35          #include "init.h"
   36          
   37          void main()
   38          {
   39   1          char command[command_size];//蓝牙控制命令
   40   1        
   41   1          char str_buffer[50];//向蓝牙发送信息的buffer
   42   1        
   43   1          char write_index = 0; //打点索引，测试用
   44   1        
   45   1          float temp_float = 0; // 零时变量
   46   1          
   47   1          //科目一开始
   48   1          pObject = Object_one_index; 
   49   1          cur_object_num = Object_one_num;
   50   1          
   51   1          //设备初始化
   52   1          init();
   53   1          
   54   1          while(1)
   55   1          {
C251 COMPILER V5.60.0,  main                                                               09/05/25  22:28:36  PAGE 2   

   56   2            get_key();
   57   2      #if IPS_USE     
   58   2            IPS114_Show_Info(); //显示必要信息
   59   2      #endif
   60   2            blue_tooth_read(command);
   61   2            /*
   62   2            命令集:
   63   2            s: 记录起始点，计算GPS误差，准备初始化yaw角
   64   2            
   65   2            b: 刹车 四个电机占空比值 0%
   66   2            
   67   2            w: 向当前科目的EEPROM区写当前位置的经纬度，写满后不可再写，只有清除后可再次重新写入。何时写满取决与
             -当前科目（未完善）
   68   2                 
   69   2            e：擦除EEPROM第一页，写索引值 0 
   70   2            
   71   2            */
   72   2            if((curState == State_Init) && key2_flag)curState = State_Unlock;
   73   2            
   74   2            switch(command[0])
   75   2            {
   76   3              case 's':
   77   3              {
   78   4                if(curState == State_Unlock)
   79   4                {
   80   5                  //装载 P1 至 target
   81   5                  LoadPoint();
   82   5                 
   83   5                  // 计算gps的漂移
   84   5                  gps_point_error[0] = gps_tau1201.latitude - target_point[0];
   85   5                  gps_point_error[1] = gps_tau1201.longitude - target_point[1];
   86   5                  
   87   5                  // 输出提示语句
   88   5                  sprintf(str_buffer,"Start!\r\nGPS Error: lat %lf lon %lf\r\n",gps_point_error[0],gps_point_er
             -ror[1]);ble6a20_send_string(str_buffer);
   89   5                  
   90   5                  // 更新状态
   91   5                  curState = State_Yaw_Init;
   92   5                }
   93   4                break;
   94   4              }
   95   3              case 'b':
   96   3              {
   97   4                curState = State_Shut;
   98   4                sprintf(str_buffer,"Break!\r \n");ble6a20_send_string(str_buffer);
   99   4                break;
  100   4              }
  101   3              case 'w':
  102   3              {
  103   4                WritePoint(pObject[write_index++]);//W25Q_PageProgram_32(0, write_buf, 2);
  104   4                sprintf(str_buffer,"Write P%d!\r\n",write_index);ble6a20_send_string(str_buffer);
  105   4                break;
  106   4              }
  107   3              case 'e':
  108   3              {
  109   4                W25Q_Erase4K_20(0, 1);//iap_erase_page(0);write_index = 0;//第一页 512k
  110   4                sprintf(str_buffer,"Erease!\r\n");ble6a20_send_string(str_buffer);
  111   4                break;
  112   4              }
  113   3              case 'A':
  114   3              {
  115   4                temp_float = func_str_to_float(&command[2]);
  116   4                switch(command[1])
  117   4                {
  118   5                  case 'P':angle_KP = temp_float;break;
  119   5                  case 'I':angle_KI = temp_float;break;
C251 COMPILER V5.60.0,  main                                                               09/05/25  22:28:36  PAGE 3   

  120   5                  case 'D':angle_KD = temp_float;break;
  121   5                }
  122   4                break;
  123   4              }
  124   3              case 'V':
  125   3              {
  126   4                temp_float = func_str_to_float(&command[2]);
  127   4                switch(command[1])
  128   4                {
  129   5                  case 'P':velocity_KP = temp_float;break;
  130   5                  case 'I':velocity_KI = temp_float;break;
  131   5                  case 'D':velocity_KD = temp_float;break;
  132   5                }
  133   4                break;          
  134   4              }
  135   3              case 'U':
  136   3              {
  137   4                curState = State_Yaw_Init;
  138   4                sprintf(str_buffer,"Start!\r\n");ble6a20_send_string(str_buffer);
  139   4                break;
  140   4              }
  141   3              default :;
  142   3            }
  143   2            //sprintf(str_buffer,"%f\r\n%f\r\n",angle_u,velocity_u);ble6a20_send_string(str_buffer);
  144   2            memset(command,0,command_size);
  145   2            refresh_button();
  146   2            
  147   2            switch(curState)
  148   2            {
  149   3              case State_Yaw_Init:
  150   3              {
  151   4                target_distance = get_two_points_distance(target_point[0],target_point[1],gps_tau1201.latitude,
             -gps_tau1201.longitude);
  152   4              
  153   4                //sprintf(str_buffer,"D:%lf \r\n",target_distance);ble6a20_send_string(str_buffer);
  154   4                
  155   4                // 离开两米后
  156   4                if(target_distance > 2)
  157   4                {
  158   5                  //计算yaw角
  159   5                  yaw = get_two_points_azimuth(target_point[0],target_point[1],gps_tau1201.latitude,gps_tau1201
             -.longitude);
  160   5                  //修正至-180~180
  161   5                  if( (180 <= yaw) && (yaw < 360))
  162   5                    yaw -= 360;
  163   5                  //修正到imu坐标系
  164   5                  yaw = - yaw;
  165   5                  //修正四元数
  166   5                  EulerToQuaternion();
  167   5                  //提示信息
  168   5                  sprintf(str_buffer,"Init! D:%lf Y:%lf\r\n",target_distance,yaw);ble6a20_send_string(str_buffe
             -r);
  169   5                  //装载下一目标点
  170   5                  LoadPoint();
  171   5      
  172   5                  sprintf(str_buffer,"Load P%d!\r\n",cur_point_num);ble6a20_send_string(str_buffer);
  173   5                  
  174   5                  curState = State_Subject_1;
  175   5                  
  176   5                  target_distance = 999;
  177   5                }
  178   4                break;
  179   4              }
  180   3              case State_Subject_1:
  181   3              {
  182   4                sprintf(str_buffer,"Error:%f!\r\n",angle_error);ble6a20_send_string(str_buffer);
C251 COMPILER V5.60.0,  main                                                               09/05/25  22:28:36  PAGE 4   

  183   4      
  184   4                target_distance = get_two_points_distance(gps_tau1201.latitude,gps_tau1201.longitude,target_poi
             -nt[0],target_point[1]);
  185   4      
  186   4                if(target_distance < 2)
  187   4                {
  188   5                   //到达目标点
  189   5                   sprintf(str_buffer,"Arrival P%d! D:%lf \r\n",cur_point_num,target_distance);ble6a20_send_str
             -ing(str_buffer);
  190   5      
  191   5                   //装载下一目标点
  192   5                   LoadPoint();
  193   5                   sprintf(str_buffer,"Load P%d!\r\n",cur_point_num);ble6a20_send_string(str_buffer);
  194   5                }
  195   4                break;
  196   4              }
  197   3              case State_Finish:
  198   3              {
  199   4                sprintf(str_buffer,"Finish!\r\n");ble6a20_send_string(str_buffer);
  200   4                while(1){};
  201   4              }
  202   3            }
  203   2      
  204   2            if(cur_point_num == cur_object_num)//先更新为结束状态
  205   2            {
  206   3              curState = State_Finish;
  207   3            }
  208   2            
  209   2            
  210   2          }
  211   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1885     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       119     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       155     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
